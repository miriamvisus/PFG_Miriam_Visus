import socket
import librosa
import numpy as np
import soundfile as sf
from pydub import AudioSegment
import io
import zlib
import subprocess


# Dirección IP y puerto del servidor
HOST = '127.0.0.1'
PORT = 8888

def receive_audio_data():
    try:
        # Crear un socket TCP/IP
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Enlazar el socket a la dirección y puerto especificados
        server_socket.bind((HOST, PORT))

        # Poner el socket en modo de escucha
        server_socket.listen(1)

        print(f"Servidor escuchando en {HOST}:{PORT}")

        # Aceptar conexiones entrantes
        client_socket, client_address = server_socket.accept()

        print(f"Conexión establecida desde {client_address}")

        # Inicializar una lista para almacenar los datos recibidos
        audio_data_chunks = []

        # Recibir los datos de audio de Unity en bloques
        while True:
            chunk = client_socket.recv(4096)  # Recibir en bloques de 4096 bytes
            if not chunk:
                break
            audio_data_chunks.append(chunk)

        # Concatenar los bloques de datos en uno solo
        audio_data = b''.join(audio_data_chunks)

        # Imprimir el tamaño de los datos recibidos
        print(f"Tamaño de los datos recibidos: {len(audio_data)} bytes")

        # Procesar los datos de audio
        tempo, energy = process_audio_data(audio_data)

        # Cerrar los sockets
        client_socket.close()
        server_socket.close()

        return tempo, energy

    except Exception as e:
        print(f"Error al recibir datos de audio: {e}")


def process_audio_data(audio_data):
    try:
        # Decodificar los datos de audio utilizando soundfile desde la memoria
        with io.BytesIO(audio_data) as audio_io:
            # Leer los datos de audio usando soundfile
            y, samplerate = sf.read(audio_io, dtype='float32')

        # Calcular el tempo del audio
        tempo, beat_frames = librosa.beat.beat_track(y=y, sr=samplerate)

        # Calcular la energía del audio
        energy = np.mean(librosa.feature.rms(y=y))

        # Devolver los resultados del análisis
        return tempo, energy

    except Exception as e:
        print(f"Error al procesar datos de audio: {e}")
        return None, None



if __name__ == "__main__":
    receive_audio_data()